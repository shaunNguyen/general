SWIG and C++:
-------------
1. file example.c

2. write an interface file which is the input to SWIG 

3. Building a Tcl module
swsscommon_wrap.cpp: $(SWIG_SOURCES)
        $(SWIG) $(SWIG_FLAG) -I../../common -o $@ $<
SWIG = /usr/bin/swig3.0
SWIG_SOURCES = ../swsscommon.i
SWIG_FLAG = -Wall -c++ -python -keyword $(am__append_1)
am__append_1 = -DSWIGWORDSIZE64

#quangnhv@quangnhv-VirtualBox:~/swig$ swig -tcl example.i
quangnhv@quangnhv-VirtualBox:~/swig$ ls
example.c  example.i  example_wrap.c
quangnhv@quangnhv-VirtualBox:~/swig$
quangnhv@quangnhv-VirtualBox:~/swig$
quangnhv@quangnhv-VirtualBox:~/swig$ cat example_wrap.c
/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1

#gcc -fpic -c example.c example_wrap.c -I/usr/local/include 
tcl8.6/tcl
sudo apt-get install tcl8.6-dev
#gcc -shared example.o example_wrap.o -o example.so
quangnhv@quangnhv-VirtualBox:~/swig$ ls
example.c  example.i  example.o  example.so  example_wrap.c  example_wrap.o
#tclsh
sudo apt install tcl

 unix % swig -tcl example.i
 unix % gcc -fpic -c example.c example_wrap.c \
        -I/usr/local/include 
 unix % gcc -shared example.o example_wrap.o -o example.so
 unix % tclsh
 % load ./example.so example
 % puts $My_variable
 3.0
 % fact 5
 120
 % my_mod 7 3
 1
 % get_time
 Sun Feb 11 23:01:07 2018

4. Building a Python module
------------------------------
quangnhv@quangnhv-VirtualBox:~/swig/python$ swig -python example.i
quangnhv@quangnhv-VirtualBox:~/swig/python$ gcc -c -fpic example.c example_wrap.c -I/usr/include/python3.8
quangnhv@quangnhv-VirtualBox:~/swig/python$ gcc -shared example.o example.o -o _example.so

===========================
BASIC SWIG :
------------
5.1 running SWIG 
			swig [options] filename
.filename : is a swig interface file or a c/c++ header file.
.options : full options swig -help 
	-go                   Generate Go wrappers
	-python               Generate Python wrappers
	-xml                  Generate XML wrappers
	-c++                  Enable C++ processing
	-allegrocl
	-chiken
	-clisp
	-cffi
	-csharp c#
	-d
	-guile
	-java
	-javascript
	-lua
	-modula3
	-mzscheme
	-ocaml
	-octave
	-perl
	-php5
	-php7
	-pike
	-r
	-ruby
	-scilab
	-sexp
	-tcl
	-uffi
	
	
5.1.1 input format 
ANSI : Amecican National Standards Institute 
- SWIG expects a file containning ANSI C/C++ declarations and special SWIG derectives. 
- *.i or *.swg 

example :
	%module mymodule 	
	%{
	#include "myheader.h"
	%}
	//now list ANSI C/C++ declarations 
	int foo;
	int bar(int x);
.module name is using in python
.everythings in the %{ .... %} block is simple copied verbatim to the resulting wrapper file created
by SWIG
	- include header file and other declarations that are required to make the generated wrapper
code compile.
	- it is important to emplasize that just because you include a declaration in a SIWG input file,
that declaration does not automatically appear in the generated wrapper code, therefor, you need to 
make sure you include the proper header files in the %{ ... %} section 

5.1.2 SWIG output 
..................
The output of SWIG is a C/C++ file that contains all of the wrapper code needed to build an extension 
module. SWIG may generate some additional files depending on the target 
By the default, an input file with the name file.i is transformed into a file file_wrap.c or file_wrap.cxx
(depending on whether or not the -c++ option has been used)
The name of the ouput C/C++ file can be changed using the -o option. 
	swig -c++ -python -o example_wrap.cpp example .i
To build the final extension module, the SWIG output file is compiled and linked with the rest of your 
C/C++ program to create a shared library 
Able to change the path when generating wrapper file 
_-f ../../Makefile SRCDIR='$(SRCDIR)' 

5.2 Wrapping Simple C declarations 
SWIG wraps simple C declarations by creating an ingertace that closely matches the way in which the declaration
would be used in a C program, 
-> due to subtle differences between languages, run-time environment..... it is not always possible to do so.
	
5.2.1 Basic type handling 
C 			target language 
int 
short
long
unsigned		integers 
signed
unsigned short
unsigned long 
unsigned char		8-bit integers
signed char		8-bit integers
bool			0/1 unless the target language provides a boolean type
-> when an intergral value is converted from C, a cast is used to convert it to the representation in the
target language
-> 16 bit short in C maybe promoted to a 32 bit integer.
-> most scripting languagues use 32-bit integers so mapping a 64-bit long integer may lead to truncation err
-> so 
int, char, short	are safe to use
unsigned int, long 	need to carefully check the correct operation
char *type is handled as a NULL-terminated ASCII string, 
> SWIG maps this into a 8-bit character string in the target scripting language  
Scripting languages :
is basically a language where instructions are written for a run time environment, 
they do not the compliatoin step and are rather interpreted
is designed for interfrating and communicating with other programming languagues
.bash
.Node js
.Ruby		SWIG
.Python		SWIG
.Perl 		SWIG
	
5.2.2 Global Variables
example :
	%module example
	doule foo;
#python
cvar.foo = 3.5
print cvar.foo
#perl
$foo = 3.5;
print $foo, "\n";
#Ruby 
Module.foo = 3.5
print Module.foo, "\n"

5.2.3 Constants 
#define 	i_CONST 	5
%constant double BLAH = 42.37;

5.2.4 A brief word about const 
starting with SWIG-1.3, all variable declaration, regardless of any use of const, are wrapped as global 
variables
if a declaration happens to be declered as const, it is wrapped as a read-only variable. 
example :
		const declarations
const char a;		//constant character
char const b;		//constant character (the same)
char *const c; 		//constant pointer to a character
const char *const d; 	//constant pointer to a constant character
		not constant 
const char *e;		// a pointer to a constant character, the pointer may be modified
e can change--it's only the value being pointed to that is read-only

5.3 Pointers and complex objects 
5.3.1 simple pointer 
5.3.2 run time pointer type checking 

5.3.3 derived types, structs, and classes 
for everythings else (structs, classes, arrays,..) SWIG applies a very simple rule :
		Everything else is a pointer
SWIG can use the type-checked pointer mechanism ( check the type of pointer) 
pointer is a variable that stores the memory addess of an object ;
.to allocate new objects on the heap
.to pass functions to other functions
.to iterate over elements in arrays or other data structures 

5.3.4 undefined datatypes 
all unspecified types are internally handled as pointers to structures or classes 
example :
void foo(size_t num);
foo(40);
->typeError : expected a _p_size_t 
The only way to fix this problem is to make sure you properly declare type names using typedef 

5.3.5 Typedef 
typedef definitions appreating in a SWIG interface are not propagated to the generated wrapper code. Therefor,
they wither need to be defined in an included header file or placed in the declaration section like this:
%{
/* Include in the generated wrapper file */
typedef unsigned int size_t;
%}
/* Tell SWIG about it */
typedef unsigned int size_t;
	or 
%inline %{
typedef unsigned int size_t;
%}
Incertain case, you might be able to include other header files to collect type info
%module example
%import "sys/types.h"
-> swig -I/usr/include -includeall example.i


=====================================
multiple files and the SWIG library :
%include : insert  code from another file into the current interface file. 
	   process 	SWIG interface files
			C header files
			C source files, SWIG will auto declare all functions it finds as "extern"
example :: 
// File : interface.i
%module package
%include equations.i
%include graphics.i
%include fileio.i
%include data.i
%include network.c
%include "../Include/user.h"  

%extern : like %include except that it only scan a file for type and class info, it does not wrap anything found 
in the input file. 

%module derived
%extern baseclass.h 				// Grab definition of a base class
// Now wrap a derived class
class Derived : public BaseClass {
public:
	...
};
-> this interface file would grab the member functions and data from a baseclass, but only use them in the 
specification of a derived class.
%extern processing of files is also useful for picking up common typedefs and definitions in a large package

%import : tells SWIG that all of the declarations in the file are indeed. 

including files on the command line :
SWIG can also include library files on the connmand using the -l options :
		swig -tcl -lswish.i interface.i

The SWIG library :
------------------
- when using %include, SWIG will search for the file in the following order :
	. The current directory
	. Directory specified with the -I option
	. ./swig_lib
	. /usr/local/lib/swig_lib (or wherever you installed SWIG) 
- in each directory, you can also create subdirectories for each target language 
- you can override the location of the SWIG library by setting the SWIG_LIB environment var 

Library example :
-----------------
the SWIG library is really a repository of "useful modules" that can be used to build better interfaces.
To use a library file, 

Creating Library files :
------------------------


